## URL Shortener Application
This repository encompasses a RESTful API utilizing Python and Flask. The application is split into two main directories: "main_modules" and "helper_modules". Additionally, this repository includes multiple test suites which cover the core functionalities.

### 1. URL Shortener Service
This simple URL shortener service accepts long URLs as input and enables users to create, update, and delete shortened URLs. The shortened URLs contain a URI generated by a combination of ASCII letters and digits. The length of this URI can be specified as a parameter and defaults to 8. The user can also specify the parameters for the maximum attempts of generating URI's, and the maximum length of of the input URLs. 

* shortener.py: responsible for handling the core functionality of the url_shortener_service. 
* shortener_helpers.py: supplies utility functions for shortener.py to validate URLs and generate distinct identifiers. 

### 2. Authentication Service
The authentication service entails user creation, login, and password updates. Users are authenticated via JWT tokens. Upon login, the supplied password is hashed and compared to the stored hash value for the corresponding username. If the hash values match, the user is authenticated and a JWT token is generated with an expiration time. The JWT tokens are validated and decoded to confirm user access and carry out role-based access control.

* auth.py: oversees user authentication and authorization, including managing user roles and validating JWT tokens.
* auth_helpers.py: provides utility functions used by auth.py to handle authentication and authorization.

### Features of application
The application features the following functionalities: 
* URL validation
* Unique identifier generation
* Collision detection among identifiers
* Creation, updating, and deleting shortened URLs utilizing role-based access control (RBAC)
* Searching and displaying all stored URLs and their corresponding URI's and timestamps
* Generating JWT tokens
* User authentication using JWT tokens
* User creation with specific access roles
* User login and password updates

### Requirements
* Python 3.8.8
* pip 22.3.1
* List of other required libraries and their versions (see below)

### Installation and Usage
1. Clone the repository or download the Python files to your local machine.
2. Install the virtualenv package by running the following command in your terminal or command prompt:
```console
pip install virtualenv
```
3. Create and activate a virtual environment:
```console
virtualenv env_name
source env_name/bin/activate # Mac or Linux
env_name\Scripts\activate.bat # Windows
```
4. Install the specified Flask version using pip (assuming pip is installed):
```console
pip install Flask==1.1.2
```
5. Install additional required libraries:
```console
pip install -r requirements.txt
```
6. Launch the Flask app:
```console
python -m main_modules.shortener
```

### Testing
This repository contains a "tests" directory which is organized into two sub-directories: "test_helper_module" and "test_main_module". These sub-directories are dedicated to test the respective helper and main module functionalities.

The shortener and shortener_helper test suites cover, among others, the following functionalities:
* Validation, generation, and retrieval of short URLs
* Redirection, updating, and deletion of short URLs
* Error handling for invalid input, unsupported requests, and non-existent unique identifiers
* Sorting URLs by date of creation

The auth and auth_helper test suites cover, among others, the following functionalities:
* Creation of users with valid username and valid password
* Generation of JWT token
* Login of users
* Updating passwords of users
* Authorization
* Encoding and decoding

### Running Tests
To initiate the tests, execute the following commands in your terminal:
```console
python -m unittest discover -s tests
```

### Limitations
The application saves data in a dictionary which may not scale effectively if the entry count grows. Dictionaries are in-memory structures that may cause performance or memory limitations. A more efficient, scalable solution would be utilizing a database, such as a relational database management system (RDBMS) or a NoSQL database.

Additionally, there is an trade-off between the generated URI length and the likelihood of collisions. A collision occurs when two distinct input URLs are assigned to identical URIs. Shorter URIs are more user-friendly and require less storage space, but they also increase the probability of collisions. When the number of unique URIs increases, so does the likelihood of collisions. This could lead to potential issues regarding the application's functionality. To tackle this problem, the application can incorporate a more advanced algorithm for producing URIs, or modify the existing algorithm's parameter to adjust the length. However, increasing the URI length may result in shortened URLs that are less convenient for users.